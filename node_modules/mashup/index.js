var router     = require("router"),
	restify    = require("restify"),
	url        = require("url"),
	linkParser = require('parse-link-header'),
	vm         = require('vm'),
	needle     = require("needle");

var	routes,
	opt = {
		prefix: '',
	};

module.exports.init = function(opt) {
	global.opt = opt || global.opt;
	routes = router();

	var prefix = global.opt.prefix || '';

	// Mashup Engine
	routes.post(prefix + '/do', function(req, res, next) {
		var startTime = (new Date()).getTime(),
			query     = url.parse(req.url, true);
		
		// Check it contains meta service uri
		if( ! query.query.url) {
			res.end(404);
			return;
		}

		// Fetch meta service
		needle.get(query.query.url, function(err, _res, body) {
			if(err || _res.statusCode != 200) {
				console.log("[Error] Fetch mata service [" + post.url + "] failed: " + (err || _res.statusCode));
				res.send((err || _res.statusCode), body);
				return;
			}
			
			// Parse link header to get orginal service & next meta serivce info
			var link = linkParser(_res.headers["link"]);
				
			// Transform URI & Reuqest
			var transform = body.toString(),
				sandbox = {
					url: {
						url: link.service.url || null,
						method: link.service.method || "GET",
						type: link.service.type || "application/json",
					},
					opt: {
						timeout: 100000,
						multipart: true,
						proxy: global.opt.proxy || false, // proxy to local service if opt.proxy provided
					},
					data: {},
					body: req.body || '',

				};

			if(global.opt.runtime == "proxy") {
				var userPolicyParser = require("../../../../lib/user-policy-header-parser.js");
				var userPolicy = global.opt.userPolicy;
				userPolicy.t += ((new Date()).getTime() - startTime) / 1000;
				//userPolicy["no-forward"] = true;
				sandbox.opt.headers = {
					"User-Policy": userPolicyParser.stringify(userPolicy),
				};
			}

			if(req.body) {
				for(var attr in req.body) {
					if(req.body.hasOwnProperty(attr)) {
						sandbox.data[attr] = req.body[attr];
					}
				}
			}

			if(req.files) {
				for(var file in req.files) {
					if(req.files.hasOwnProperty(file)) {
						sandbox.data[file] = {file: req.files[file].path, content_type: req.files[file].type};
					}
				}
			}

			sandbox._data = sandbox.data;

			vm.runInNewContext(transform + "if(trans_uri) {trans_uri();} if(trans_req) {trans_req();}" ,sandbox);
			// Generate request to original service
			needle[sandbox.url.method.toLowerCase()](sandbox.url.url, sandbox.data, sandbox.opt, function(err, _res, body) {
				if(err) {
					console.log("[Error] Original service request failed: " + err);
					res.send(err, body);
					return;
				}
/*
				if(_res.statusCode == 440) { // no forward (only happen on proxy
					//TODO 更新 utilty
					userPolicy.t += ((new Date()).getTime() - startTime) / 1000;
					sandbox.opt.headers["User-Policy"] = userPolicyParser.stringify(userPolicy);
					sandbox.opt.proxy = false;
					needle.post(link.engine.url + "?url=" + encodeURIComponent(query.query.url), sandbox._data, sandbox.opt, function(err, _res, body) {
						if(err) {
							console.log("[Error] Next run request failed:" + err);
							res.send(err, body);
							return;
						}
						console.log("[OK] Get result form next");
						res.headers = _res.headers;
						res.send(_res.statusCode, body);
					});
					return;
				}
*/
				if(_res.statusCode != 200) {
					res.headers = _res.headers;
					res.send(_res.statusCode, body);
					return;
				}
				
				// Transform Response
				sandbox.res = _res;
				sandbox.body = body;
				sandbox.opt = {
					timeout: 100000,
					multipart: true,
				    proxy: global.opt.proxy || false,
				    headers: {},
				};
				sandbox.data = {};
				vm.runInNewContext(transform + "if(trans_res) {trans_res();}", sandbox);
				
				// Generate request to next meta serivce, if exist
				if(link.next && link.next.url && link.engine && link.engine.url) {
					if(global.opt.runtime == "proxy") {
						userPolicy.t += ((new Date()).getTime() - startTime) / 1000;
						sandbox.opt.headers["User-Policy"] = userPolicyParser.stringify(userPolicy);
					}
					needle.post(link.engine.url + "?url=" + encodeURIComponent(link.next.url), sandbox.data, sandbox.opt, function(err, _res, body) {
						if(err) {
							console.log("[Error] Next run request failed:" + err);
							res.send(err, body);
							return;
						}
						//console.log("[OK] Get result form next");
						//res.headers = _res.headers;
						if(_res.headers["x-count"]) {
							res.setHeader("X-Count", parseInt(_res.headers["x-count"]) + 1);
						}
						console.log("x-count:" + (parseInt(_res.headers["x-count"]) + 1));
						console.log("mash time:" +  ((new Date()).getTime() - startTime) / 1000.0);
						console.log("-----------------------------------------------------");
						res.send(_res.statusCode, body);
					});
				} else {
					//console.log("[OK] Successed, end with no next");
					//res.headers = _res.headers;
					if(_res.headers["x-count"]) {
						res.setHeader("X-Count", _res.headers["x-count"]);
					}
					res.send(_res.statusCode, sandbox.body);
				}
			});
		});
	});

	// Error handling

	function error(req, res, next) {
		next(new restify.ResourceNotFoundError());
	}

	routes.get(error)
		  .head(error)
		  .post(error)
		  .put(error)
		  .del(error);
}

// -- Routing
// ------------------------------------------------
// Module entry point
// ------------------------------------------------

module.exports.route = function(req, res, next) {
	return routes(req, res, function(err){
		if( ! next) {
			return;
		}

		if(err) {
			next(err);
		} else {
			next(new restify.MethodNotAllowedError());
		}
	});
}

/* End of file mashup/index.js */

